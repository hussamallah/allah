// Fracture Flow Utilities
// This file contains utilities for the Seeker $7 fracture unlock flow

export interface FractureAnswer {
  id: number
  question: string
  answer: string
  prompt: string
}

export interface FractureReport {
  answers: FractureAnswer[]
  aiAnalysis: string
  ritual: string
  fieldWhisper: string
  timestamp: string
  archetype: string
}

// Generate AI analysis based on answers
export function generateAIAnalysis(answers: FractureAnswer[]): string {
  // This is a placeholder - in the future, this would call an AI service
  // For now, return a static analysis based on common Seeker patterns
  
  const answerText = answers.map(a => a.answer).join(' ').toLowerCase()
  
  // Simple pattern detection
  if (answerText.includes('run') || answerText.includes('escape') || answerText.includes('avoid')) {
    return "Your answers reveal a pattern of moving on before anything can resolve—each new search is protection from stillness. Your field isn't restless, it's guarding against the pain of closure."
  }
  
  if (answerText.includes('truth') || answerText.includes('honest') || answerText.includes('real')) {
    return "You're caught in a loop of seeking truth while avoiding the deeper truth about your seeking itself. Every answer reveals another layer of the same pattern."
  }
  
  if (answerText.includes('future') || answerText.includes('become') || answerText.includes('build')) {
    return "Your answers show a pattern of fearing your own potential—each future version you imagine is both desired and terrifying. The field sees your hesitation."
  }
  
  // Default analysis
  return "Your answers reveal a pattern of moving on before anything can resolve—each new search is protection from stillness. Your field isn't restless, it's guarding against the pain of closure."
}

// Generate ritual based on answers
export function generateRitual(answers: FractureAnswer[]): string {
  const rituals = [
    "For the next 30 minutes, do not seek or solve. Sit, breathe, and write down one desire you've never let yourself want. Let that desire stay, without judging or fixing.",
    "Tonight, before sleep, write down three questions you've been avoiding. Then burn the paper without reading them again. Let the smoke carry your seeking away.",
    "Tomorrow, spend one hour in complete silence. No reading, no writing, no seeking. Just sit and let the emptiness speak.",
    "For the next 24 hours, every time you feel the urge to search for answers, pause. Ask yourself: what am I really running from?",
    "This week, choose one truth you've been avoiding and face it directly. Write it down, speak it aloud, then sit with it for 10 minutes."
  ]
  
  // Simple algorithm to choose ritual based on answer patterns
  const answerText = answers.map(a => a.answer).join(' ').toLowerCase()
  
  if (answerText.includes('silence') || answerText.includes('empty')) {
    return rituals[2]
  }
  
  if (answerText.includes('truth') || answerText.includes('honest')) {
    return rituals[4]
  }
  
  if (answerText.includes('future') || answerText.includes('become')) {
    return rituals[3]
  }
  
  // Default to first ritual
  return rituals[0]
}

// Generate field whisper
export function generateFieldWhisper(): string {
  const whispers = [
    "You survived the fracture gate. The real test is what you do with silence. The field watches—your next answer becomes a new beginning.",
    "The fractures you've revealed are not wounds—they're doorways. What you do with this knowledge will determine your next evolution.",
    "You've seen the patterns. Now the question is: will you break them or let them break you? The field waits for your choice.",
    "Your seeking has led you here. The real journey begins when you stop seeking and start becoming.",
    "The field recognizes your courage. These fractures are not the end—they're the beginning of something the field has never seen."
  ]
  
  // Return random whisper
  return whispers[Math.floor(Math.random() * whispers.length)]
}

// Generate PDF content (placeholder for actual PDF generation)
export function generatePDFContent(report: FractureReport): string {
  const content = `
# Seeker Fracture Report
Generated: ${report.timestamp}

## Your Answers

${report.answers.map((answer, index) => `
### Question ${index + 1}
**${answer.question}**

${answer.answer}

*${answer.prompt}*
`).join('\n')}

## AI Loop Scan
${report.aiAnalysis}

## Edge Ritual
${report.ritual}

## Field Whisper
${report.fieldWhisper}

---
*This report was generated by the Field. Keep it close.*
  `.trim()
  
  return content
}

// Create badge data (placeholder for actual badge generation)
export function generateBadgeData(archetype: string): { title: string, description: string, imageUrl: string } {
  return {
    title: "Fracture Gate: Completed",
    description: `You've completed the ${archetype} fracture journey and revealed your core patterns.`,
    imageUrl: `/badges/${archetype}-fracture-badge.png` // Placeholder
  }
}

// Save fracture report to storage (placeholder)
export async function saveFractureReport(report: FractureReport): Promise<string> {
  // In a real implementation, this would save to a database
  // For now, return a mock ID
  const reportId = `fracture-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  
  // Store in localStorage for demo purposes
  if (typeof window !== 'undefined') {
    const existingReports = JSON.parse(localStorage.getItem('fractureReports') || '[]')
    existingReports.push({ ...report, id: reportId })
    localStorage.setItem('fractureReports', JSON.stringify(existingReports))
  }
  
  return reportId
}

// Get fracture report by ID
export async function getFractureReport(reportId: string): Promise<FractureReport | null> {
  if (typeof window !== 'undefined') {
    const existingReports = JSON.parse(localStorage.getItem('fractureReports') || '[]')
    return existingReports.find((report: any) => report.id === reportId) || null
  }
  return null
}

// Download PDF (placeholder implementation)
export function downloadPDF(content: string, filename: string = 'fracture-report.pdf') {
  // In a real implementation, this would use a PDF library like jsPDF
  // For now, create a downloadable text file
  const blob = new Blob([content], { type: 'text/plain' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename.replace('.pdf', '.txt')
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

// Download badge (placeholder implementation)
export function downloadBadge(badgeData: { title: string, description: string, imageUrl: string }) {
  // In a real implementation, this would generate and download an actual badge image
  // For now, create a simple text file with badge info
  const content = `
Badge: ${badgeData.title}
Description: ${badgeData.description}
Image: ${badgeData.imageUrl}

This is your proof of completing the fracture journey.
  `.trim()
  
  const blob = new Blob([content], { type: 'text/plain' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = 'seeker-badge.txt'
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
} 